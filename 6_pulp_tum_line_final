# =============================================================================
# EYLÃœL HAFTA SONU - MIP Ä°LE SHIFT OPTÄ°MÄ°ZASYONU
# Grup bazlÄ± dengeleme ile
# =============================================================================

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from pulp import *

# =============================================================================
# 0. VERÄ° YÃœKLEME
# =============================================================================

print("Veriler yÃ¼kleniyor...")

df_shifts = pd.read_excel('vardiyalar.xlsx')
df_actual = pd.read_excel('gercek_calisanlar.xlsx')
df_actual['working_date'] = pd.to_datetime(df_actual['working_date'])

print(f"âœ“ Shift sayÄ±sÄ±: {len(df_shifts)}")
print(f"âœ“ GerÃ§ek Ã§alÄ±ÅŸan satÄ±r: {len(df_actual):,}")

queue_company_rules = {
    'a_cagrilari': ['inhouse', 'outsource'],
    'b_cagrilari': ['inhouse'],
    'c_cagrilari': ['inhouse']
}

# =============================================================================
# 1. YARDIMCI FONKSÄ°YONLAR
# =============================================================================

def is_slot_in_shift(slot, start, end):
    """Slot bu shift iÃ§inde mi?"""
    if start <= end:
        return start <= slot < end
    else:
        return slot >= start or slot < end


def create_shift_coverage_matrix(df_shifts):
    """Her shift'in hangi slotlarÄ± kapsadÄ±ÄŸÄ±nÄ± hesapla"""
    shift_coverage = {}
    
    for _, row in df_shifts.iterrows():
        shift = row['shift']
        start = str(row['start'])[:5]
        end = str(row['end'])[:5]
        company = row['company']
        
        key = f"{shift}_{company}"
        
        slots = []
        for h in range(24):
            for m in ['00', '30']:
                slot = f"{h:02d}:{m}"
                if is_slot_in_shift(slot, start, end):
                    slots.append(slot)
        
        shift_coverage[key] = {
            'shift': shift,
            'company': company,
            'start': start,
            'end': end,
            'slots': slots
        }
    
    return shift_coverage


def calculate_actual_by_slot(df_actual, date, queue):
    """Belirli gÃ¼n ve kuyruk iÃ§in slot bazÄ±nda gerÃ§ek Ã§alÄ±ÅŸan (TOPLAM)"""
    df_day = df_actual[
        (df_actual['working_date'] == date) &
        (df_actual['line_based_main_group'] == queue)
    ]
    
    slots = [f"{h:02d}:{m}" for h in range(24) for m in ['00', '30']]
    actual_by_slot = {}
    
    for slot in slots:
        count = 0
        for _, row in df_day.iterrows():
            start = str(row['shifts_start_hour'])[:5]
            end = str(row['shifts_end_hour'])[:5]
            
            if is_slot_in_shift(slot, start, end):
                count += row['calisan_kisi_sayisi']
        
        actual_by_slot[slot] = count
    
    return actual_by_slot


def calculate_actual_by_slot_by_company(df_actual, date, queue):
    """Slot bazÄ±nda inhouse/outsource ayrÄ± hesapla"""
    df_day = df_actual[
        (df_actual['working_date'] == date) &
        (df_actual['line_based_main_group'] == queue)
    ]
    
    slots = [f"{h:02d}:{m}" for h in range(24) for m in ['00', '30']]
    
    actual_inhouse = {}
    actual_outsource = {}
    
    for slot in slots:
        count_in = 0
        count_out = 0
        
        for _, row in df_day.iterrows():
            start = str(row['shifts_start_hour'])[:5]
            end = str(row['shifts_end_hour'])[:5]
            
            if is_slot_in_shift(slot, start, end):
                if row['outsource_flg'] == 0:
                    count_in += row['calisan_kisi_sayisi']
                else:
                    count_out += row['calisan_kisi_sayisi']
        
        actual_inhouse[slot] = count_in
        actual_outsource[slot] = count_out
    
    return actual_inhouse, actual_outsource


def calculate_actual_by_start_hour(df_actual, date, queue):
    """Vardiya baÅŸlangÄ±Ã§ saatine gÃ¶re inhouse/outsource kiÅŸi sayÄ±sÄ±"""
    df_day = df_actual[
        (df_actual['working_date'] == date) &
        (df_actual['line_based_main_group'] == queue)
    ]
    
    actual_inhouse_start = {}
    actual_outsource_start = {}
    
    for _, row in df_day.iterrows():
        start = str(row['shifts_start_hour'])[:5]
        count = row['calisan_kisi_sayisi']
        
        if row['outsource_flg'] == 0:
            actual_inhouse_start[start] = actual_inhouse_start.get(start, 0) + count
        else:
            actual_outsource_start[start] = actual_outsource_start.get(start, 0) + count
    
    return actual_inhouse_start, actual_outsource_start


# =============================================================================
# 2. MIP OPTÄ°MÄ°ZASYON FONKSÄ°YONU (GRUP BAZLI DENGELEME)
# =============================================================================

def optimize_shifts_mip(need_by_slot, shift_coverage, 
                        target_min_outsource=0.55,
                        target_max_outsource=0.65,
                        min_per_shift=5,
                        cost_inhouse=1.0,
                        cost_outsource=1.01,
                        balance_weight=10,
                        shift_cost_overrides=None):
    """
    MIP ile shift optimizasyonu - Grup bazlÄ± dengeleme
    
    Parameters:
    -----------
    need_by_slot : dict
        Her slot iÃ§in ihtiyaÃ§ {slot: count}
    shift_coverage : dict
        Her shift'in bilgisi
    target_min_outsource : float
        GÃ¼nlÃ¼k minimum outsource oranÄ±
    target_max_outsource : float
        GÃ¼nlÃ¼k maksimum outsource oranÄ±
    min_per_shift : int
        Bir shift kullanÄ±lÄ±yorsa minimum kiÅŸi sayÄ±sÄ±
    cost_inhouse : float
        Inhouse maliyet Ã§arpanÄ±
    cost_outsource : float
        Outsource maliyet Ã§arpanÄ±
    balance_weight : float
        Dengeleme aÄŸÄ±rlÄ±ÄŸÄ± (0=dengeleme yok, 10=orta, 50=gÃ¼Ã§lÃ¼)
    shift_cost_overrides : dict
        Belirli saatler iÃ§in Ã¶zel maliyet tanÄ±mlarÄ±
        Ã–rnek: {'07:30': {'inhouse': 1.05}, '19:00': {'outsource': 1.15}}
    """
    
    if shift_cost_overrides is None:
        shift_cost_overrides = {}
    
    prob = LpProblem("Shift_Optimization", LpMinimize)
    
    shifts = list(shift_coverage.keys())
    slots = [f"{h:02d}:{m}" for h in range(24) for m in ['00', '30']]
    active_slots = [s for s in slots if need_by_slot.get(s, 0) > 0]
    
    inhouse_shifts = [s for s in shifts if '_inhouse' in s.lower()]
    outsource_shifts = [s for s in shifts if '_outsource' in s.lower()]
    
    # =========================================
    # VARDIYA BAÅžLANGIÃ‡ GRUPLARI
    # =========================================
    
    shift_groups = {
        'sabah': ['07:00', '07:30', '08:00', '08:30', '09:00'],
        'gunduz': ['09:30', '10:00', '10:30', '11:00'],
        'ara': ['11:30', '12:00', '12:30', '13:00', '13:30', '14:00', '14:30', '15:00', '15:30', '16:00', '16:30'],
        'aksam': ['17:00', '18:00', '19:00'],
        'gece': ['00:00', '01:00', '02:00', '03:00', '04:00', '05:00', '06:00', '06:30']
    }
    
    # Her gruptaki shift'leri bul
    group_shifts = {}
    for group_name, start_hours in shift_groups.items():
        group_shifts[group_name] = []
        for s in shifts:
            if shift_coverage[s]['start'] in start_hours:
                group_shifts[group_name].append(s)
    
    # =========================================
    # DEÄžÄ°ÅžKENLER
    # =========================================
    
    # x[shift] = bu shift'e atanan kiÅŸi sayÄ±sÄ± (integer)
    x = LpVariable.dicts("x", shifts, lowBound=0, cat='Integer')
    
    # y[shift] = bu shift kullanÄ±lÄ±yor mu? (binary)
    y = LpVariable.dicts("y", shifts, cat='Binary')
    
    # z_group[group] = her gruptaki maksimum shift kiÅŸi sayÄ±sÄ±
    z_group = {}
    for group_name in shift_groups.keys():
        z_group[group_name] = LpVariable(f"z_{group_name}", lowBound=0)
    
    # =========================================
    # AMAÃ‡ FONKSÄ°YONU
    # =========================================
    
    # Toplam maliyet (esnek maliyet hesaplama)
    cost_list = []
    for s in shifts:
        start = shift_coverage[s]['start']
        company = shift_coverage[s]['company']
        
        # VarsayÄ±lan maliyet
        if company == 'inhouse':
            base_cost = cost_inhouse
        else:
            base_cost = cost_outsource
        
        # Override var mÄ± kontrol et
        if start in shift_cost_overrides:
            if company in shift_cost_overrides[start]:
                base_cost = shift_cost_overrides[start][company]
        
        cost_list.append(x[s] * base_cost)
    
    total_cost = lpSum(cost_list)
    
    # Dengeleme cezasÄ± (grup max'larÄ±nÄ±n toplamÄ±)
    balance_penalty = lpSum([z_group[g] for g in shift_groups.keys()])
    
    # AmaÃ§: maliyet + dengeleme
    prob += total_cost + balance_weight * balance_penalty
    
    # =========================================
    # KISITLAR
    # =========================================
    
    # 1. Her slotta ihtiyacÄ± karÅŸÄ±la
    for slot in active_slots:
        covering_shifts = [s for s in shifts if slot in shift_coverage[s]['slots']]
        if covering_shifts:
            prob += lpSum([x[s] for s in covering_shifts]) >= need_by_slot[slot]
    
    # 2. Shift kullanÄ±lÄ±yorsa en az min_per_shift kiÅŸi
    M = 200
    for s in shifts:
        prob += x[s] <= M * y[s]              # y=0 ise x=0
        prob += x[s] >= min_per_shift * y[s]  # y=1 ise x>=5
    
    # 3. GÃ¼nlÃ¼k outsource oranÄ± (sadece karma kuyruklar iÃ§in)
    if not only_inhouse:
        total_inhouse = 0
        for s in inhouse_shifts:
            total_inhouse += x[s]
        
        total_outsource = 0
        for s in outsource_shifts:
            total_outsource += x[s]
        
        prob += (1 - target_min_outsource) * total_outsource >= target_min_outsource * total_inhouse
        prob += (1 - target_max_outsource) * total_outsource <= target_max_outsource * total_inhouse
    
    # outsource >= min_ratio * (inhouse + outsource)
    prob += (1 - target_min_outsource) * total_outsource >= target_min_outsource * total_inhouse
    
    # outsource <= max_ratio * (inhouse + outsource)
    prob += (1 - target_max_outsource) * total_outsource <= target_max_outsource * total_inhouse
    
    # 4. Grup iÃ§i dengeleme: her shift kendi grubunun max'Ä±ndan kÃ¼Ã§Ã¼k olsun
    for group_name, shift_list in group_shifts.items():
        for s in shift_list:
            prob += x[s] <= z_group[group_name]
    
    # =========================================
    # Ã‡Ã–ZÃœM
    # =========================================
    
    prob.solve(PULP_CBC_CMD(msg=0))
    
    if LpStatus[prob.status] == 'Optimal':
        assignments = {}
        for s in shifts:
            val = value(x[s])
            if val and val > 0:
                assignments[s] = int(val)
        
        # Ã–zet hesapla
        total_in = sum(v for s, v in assignments.items() if s in inhouse_shifts)
        total_out = sum(v for s, v in assignments.items() if s in outsource_shifts)
        ratio = total_out / (total_in + total_out) if (total_in + total_out) > 0 else 0
        
        # Grup max'larÄ±nÄ± al
        group_maxes = {g: value(z_group[g]) for g in shift_groups.keys()}
        
        return assignments, f"Optimal (outsource: {ratio:.1%})", group_maxes
    else:
        return None, LpStatus[prob.status], None


# =============================================================================
# 3. ANALÄ°Z FONKSÄ°YONU
# =============================================================================

def analyze_mip_result(assignments, shift_coverage, need_by_slot):
    """MIP sonucunu analiz et"""
    
    if assignments is None:
        return None
    
    slots = [f"{h:02d}:{m}" for h in range(24) for m in ['00', '30']]
    
    inhouse_shifts = [s for s in assignments.keys() if '_inhouse' in s.lower()]
    outsource_shifts = [s for s in assignments.keys() if '_outsource' in s.lower()]
    
    # GÃ¼nlÃ¼k toplam
    total_inhouse = sum(assignments.get(s, 0) for s in inhouse_shifts)
    total_outsource = sum(assignments.get(s, 0) for s in outsource_shifts)
    total = total_inhouse + total_outsource
    
    # Slot bazÄ±nda daÄŸÄ±lÄ±m
    slot_inhouse = {}
    slot_outsource = {}
    
    for slot in slots:
        in_count = 0
        out_count = 0
        
        for shift, count in assignments.items():
            if shift in shift_coverage and slot in shift_coverage[shift]['slots']:
                if '_inhouse' in shift.lower():
                    in_count += count
                else:
                    out_count += count
        
        slot_inhouse[slot] = in_count
        slot_outsource[slot] = out_count
    
    # Zirve slot
    active_slots = [s for s in slots if need_by_slot.get(s, 0) > 0]
    if active_slots:
        max_slot = max(active_slots, key=lambda s: need_by_slot[s])
        peak_inhouse = slot_inhouse[max_slot]
        peak_outsource = slot_outsource[max_slot]
    else:
        max_slot = None
        peak_inhouse = 0
        peak_outsource = 0
    
    return {
        'total': total,
        'inhouse': total_inhouse,
        'outsource': total_outsource,
        'inhouse_pct': total_inhouse / total * 100 if total > 0 else 0,
        'outsource_pct': total_outsource / total * 100 if total > 0 else 0,
        'peak_slot': max_slot,
        'peak_inhouse': peak_inhouse,
        'peak_outsource': peak_outsource,
        'slot_inhouse': slot_inhouse,
        'slot_outsource': slot_outsource,
        'num_shifts_used': len(assignments)
    }


# =============================================================================
# 4. KARÅžILAÅžTIRMA GRAFÄ°K FONKSÄ°YONU
# =============================================================================

def compare_actual_vs_mip(date, queue, df_actual, assignments, shift_coverage):
    """GerÃ§ek vs MIP karÅŸÄ±laÅŸtÄ±rmasÄ± - 4 grafik"""
    
    date_str = pd.to_datetime(date).strftime('%Y-%m-%d')
    slots = [f"{h:02d}:{m}" for h in range(24) for m in ['00', '30']]
    
    # =========================================
    # GERÃ‡EK VERÄ°LER
    # =========================================
    
    actual_inhouse_start, actual_outsource_start = calculate_actual_by_start_hour(df_actual, date, queue)
    actual_inhouse_slot, actual_outsource_slot = calculate_actual_by_slot_by_company(df_actual, date, queue)
    
    # =========================================
    # MIP VERÄ°LER
    # =========================================
    
    # Vardiya baÅŸlangÄ±Ã§ saatlerine gÃ¶re
    mip_inhouse_start = {}
    mip_outsource_start = {}
    
    for shift, count in assignments.items():
        if shift in shift_coverage:
            info = shift_coverage[shift]
            start = info['start']
            
            if info['company'] == 'inhouse':
                mip_inhouse_start[start] = mip_inhouse_start.get(start, 0) + count
            else:
                mip_outsource_start[start] = mip_outsource_start.get(start, 0) + count
    
    # Slot bazÄ±nda
    mip_inhouse_slot = {}
    mip_outsource_slot = {}
    
    for slot in slots:
        count_in = 0
        count_out = 0
        
        for shift, count in assignments.items():
            if shift in shift_coverage and slot in shift_coverage[shift]['slots']:
                if shift_coverage[shift]['company'] == 'inhouse':
                    count_in += count
                else:
                    count_out += count
        
        mip_inhouse_slot[slot] = count_in
        mip_outsource_slot[slot] = count_out
    
    # =========================================
    # GRAFÄ°KLER
    # =========================================
    
    fig, axes = plt.subplots(2, 2, figsize=(16, 12))
    fig.suptitle(f'GerÃ§ek vs MIP KarÅŸÄ±laÅŸtÄ±rmasÄ± - {date_str}', fontsize=14, fontweight='bold')
    
    # --- Grafik 1: Inhouse Vardiya BaÅŸlangÄ±Ã§ ---
    ax1 = axes[0, 0]
    all_starts = sorted(set(list(actual_inhouse_start.keys()) + list(mip_inhouse_start.keys())))
    x_axis = range(len(all_starts))
    width = 0.35
    
    actual_vals = [actual_inhouse_start.get(s, 0) for s in all_starts]
    mip_vals = [mip_inhouse_start.get(s, 0) for s in all_starts]
    
    ax1.bar([i - width/2 for i in x_axis], actual_vals, width, label='GerÃ§ek', color='#2E86AB', alpha=0.7)
    ax1.bar([i + width/2 for i in x_axis], mip_vals, width, label='MIP', color='#A23B72', alpha=0.7)
    
    ax1.set_xlabel('Vardiya BaÅŸlangÄ±Ã§ Saati')
    ax1.set_ylabel('KiÅŸi SayÄ±sÄ±')
    ax1.set_title('INHOUSE - Vardiya BaÅŸlangÄ±Ã§ DaÄŸÄ±lÄ±mÄ±')
    ax1.set_xticks(x_axis)
    ax1.set_xticklabels(all_starts, rotation=45, ha='right', fontsize=8)
    ax1.legend()
    ax1.grid(axis='y', alpha=0.3)
    
    # --- Grafik 2: Outsource Vardiya BaÅŸlangÄ±Ã§ ---
    ax2 = axes[0, 1]
    all_starts = sorted(set(list(actual_outsource_start.keys()) + list(mip_outsource_start.keys())))
    x_axis = range(len(all_starts))
    
    actual_vals = [actual_outsource_start.get(s, 0) for s in all_starts]
    mip_vals = [mip_outsource_start.get(s, 0) for s in all_starts]
    
    ax2.bar([i - width/2 for i in x_axis], actual_vals, width, label='GerÃ§ek', color='#2E86AB', alpha=0.7)
    ax2.bar([i + width/2 for i in x_axis], mip_vals, width, label='MIP', color='#A23B72', alpha=0.7)
    
    ax2.set_xlabel('Vardiya BaÅŸlangÄ±Ã§ Saati')
    ax2.set_ylabel('KiÅŸi SayÄ±sÄ±')
    ax2.set_title('OUTSOURCE - Vardiya BaÅŸlangÄ±Ã§ DaÄŸÄ±lÄ±mÄ±')
    ax2.set_xticks(x_axis)
    ax2.set_xticklabels(all_starts, rotation=45, ha='right', fontsize=8)
    ax2.legend()
    ax2.grid(axis='y', alpha=0.3)
    
    # --- Grafik 3: Slot BazÄ±nda Toplam ---
    ax3 = axes[1, 0]
    
    active_slots = [s for s in slots if 
                    actual_inhouse_slot[s] + actual_outsource_slot[s] > 0 or
                    mip_inhouse_slot[s] + mip_outsource_slot[s] > 0]
    
    actual_total = [actual_inhouse_slot[s] + actual_outsource_slot[s] for s in active_slots]
    mip_total = [mip_inhouse_slot[s] + mip_outsource_slot[s] for s in active_slots]
    
    ax3.plot(range(len(active_slots)), actual_total, 'o-', label='GerÃ§ek', color='#2E86AB', linewidth=2)
    ax3.plot(range(len(active_slots)), mip_total, 's--', label='MIP', color='#A23B72', linewidth=2)
    
    ax3.set_xlabel('Slot')
    ax3.set_ylabel('KiÅŸi SayÄ±sÄ±')
    ax3.set_title('SLOT BAZINDA TOPLAM KÄ°ÅžÄ° SAYISI')
    ax3.set_xticks(range(0, len(active_slots), 4))
    ax3.set_xticklabels([active_slots[i] for i in range(0, len(active_slots), 4)], rotation=45, ha='right')
    ax3.legend()
    ax3.grid(alpha=0.3)
    
    # --- Grafik 4: Slot BazÄ±nda Inhouse vs Outsource ---
    ax4 = axes[1, 1]
    
    # GerÃ§ek - iÃ§i dolu alan
    ax4.fill_between(range(len(active_slots)), 
                     [actual_inhouse_slot[s] for s in active_slots],
                     alpha=0.4, label='GerÃ§ek Inhouse', color='#2E86AB')
    ax4.fill_between(range(len(active_slots)), 
                     [actual_outsource_slot[s] for s in active_slots],
                     alpha=0.4, label='GerÃ§ek Outsource', color='#E94F37')
    
    # MIP - kesikli Ã§izgi
    ax4.plot(range(len(active_slots)), [mip_inhouse_slot[s] for s in active_slots], 
             '--', label='MIP Inhouse', color='#2E86AB', linewidth=2)
    ax4.plot(range(len(active_slots)), [mip_outsource_slot[s] for s in active_slots], 
             '--', label='MIP Outsource', color='#E94F37', linewidth=2)
    
    ax4.set_xlabel('Slot')
    ax4.set_ylabel('KiÅŸi SayÄ±sÄ±')
    ax4.set_title('SLOT BAZINDA INHOUSE vs OUTSOURCE')
    ax4.set_xticks(range(0, len(active_slots), 4))
    ax4.set_xticklabels([active_slots[i] for i in range(0, len(active_slots), 4)], rotation=45, ha='right')
    ax4.legend()
    ax4.grid(alpha=0.3)
    
    plt.tight_layout()
    plt.savefig(f'mip_comparison_{date_str}.png', dpi=150, bbox_inches='tight')
    plt.show()
    
    # =========================================
    # Ã–ZET TABLO
    # =========================================
    
    total_actual_in = sum(actual_inhouse_start.values())
    total_actual_out = sum(actual_outsource_start.values())
    total_mip_in = sum(mip_inhouse_start.values())
    total_mip_out = sum(mip_outsource_start.values())
    
    print(f"\nðŸ“Š Ã–ZET - {date_str}")
    print(f"{'-'*50}")
    print(f"{'':20} {'GerÃ§ek':>12} {'MIP':>12}")
    print(f"{'-'*50}")
    print(f"{'Inhouse':20} {total_actual_in:>12} {total_mip_in:>12}")
    print(f"{'Outsource':20} {total_actual_out:>12} {total_mip_out:>12}")
    print(f"{'TOPLAM':20} {total_actual_in+total_actual_out:>12} {total_mip_in+total_mip_out:>12}")
    print(f"{'-'*50}")
    actual_ratio = total_actual_out / (total_actual_in + total_actual_out) * 100 if (total_actual_in + total_actual_out) > 0 else 0
    mip_ratio = total_mip_out / (total_mip_in + total_mip_out) * 100 if (total_mip_in + total_mip_out) > 0 else 0
    print(f"{'Outsource OranÄ±':20} {actual_ratio:>11.1f}% {mip_ratio:>11.1f}%")
    
    print(f"\nâœ“ Grafik kaydedildi: mip_comparison_{date_str}.png")


# =============================================================================
# 5. VERÄ°LERÄ° HAZIRLA
# =============================================================================
# =============================================================================
# 5. VERÄ°LERÄ° HAZIRLA
# =============================================================================

# Kuyruk seÃ§
queue = 'a_cagrilari'  # 'a_cagrilari', 'b_cagrilari', 'c_cagrilari'

# Otomatik belirle - sadece inhouse mu?
only_inhouse = (queue_company_rules[queue] == ['inhouse'])

df_eylul = df_actual[df_actual['working_date'].dt.month == 9]

weekend_dates = sorted(df_eylul[
    (df_eylul['line_based_main_group'] == queue) & 
    (df_eylul['weekend_flg'] == 1)
]['working_date'].unique())

print(f"\n{'='*60}")
print(f"EYLÃœL HAFTA SONU - MIP OPTÄ°MÄ°ZASYONU")
print(f"{'='*60}")
print(f"Kuyruk: {queue}")
print(f"Sadece inhouse: {only_inhouse}")
print(f"Hafta sonu gÃ¼nÃ¼: {len(weekend_dates)}")

df_shifts_filtered = df_shifts[df_shifts['company'].isin(queue_company_rules[queue])]
shift_coverage = create_shift_coverage_matrix(df_shifts_filtered)

print(f"\nKullanÄ±labilir Shift: {len(shift_coverage)}")
if not only_inhouse:
    inhouse_count = 0
    outsource_count = 0
    for s in shift_coverage.values():
        if s['company'] == 'inhouse':
            inhouse_count += 1
        else:
            outsource_count += 1
    print(f"  Inhouse: {inhouse_count}")
    print(f"  Outsource: {outsource_count}")


# =============================================================================
# 6. MIP TESTLERÄ°NÄ° Ã‡ALIÅžTIR
# =============================================================================

print(f"\n{'='*80}")
print("MIP OPTÄ°MÄ°ZASYON SONUÃ‡LARI")
print(f"{'='*80}")

# Ã–zel maliyet tanÄ±mlarÄ± (kuyruÄŸa gÃ¶re)
if queue == 'a_cagrilari':
    shift_cost_overrides = {
        '07:30': {'inhouse': 1.05}
    }
elif queue == 'b_cagrilari':
    shift_cost_overrides = {
        # b_cagrilari iÃ§in Ã¶zel maliyet varsa buraya ekle
    }
elif queue == 'c_cagrilari':
    shift_cost_overrides = {
        # c_cagrilari iÃ§in Ã¶zel maliyet varsa buraya ekle
    }
else:
    shift_cost_overrides = {}

if len(shift_cost_overrides) > 0:
    print(f"\nðŸ“Œ Ã–zel maliyet tanÄ±mlarÄ±:")
    for saat, costs in shift_cost_overrides.items():
        for company, cost in costs.items():
            print(f"   {saat} {company}: {cost}")
else:
    print(f"\nðŸ“Œ Ã–zel maliyet tanÄ±mÄ± yok, varsayÄ±lan kullanÄ±lacak")

all_results = []

for date in weekend_dates:
    date_str = pd.to_datetime(date).strftime('%Y-%m-%d')
    
    # Ä°htiyaÃ§ hesapla
    actual_by_slot = calculate_actual_by_slot(df_actual, date, queue)
    
    # MIP Ã§alÄ±ÅŸtÄ±r
    assignments, status, group_maxes = optimize_shifts_mip(
        need_by_slot=actual_by_slot,
        shift_coverage=shift_coverage,
        target_min_outsource=0.55,
        target_max_outsource=0.65,
        min_per_shift=5,
        cost_inhouse=1.0,
        cost_outsource=1.01,
        balance_weight=10,
        shift_cost_overrides=shift_cost_overrides,
        only_inhouse=only_inhouse
    )
    
    if assignments:
        analysis = analyze_mip_result(assignments, shift_coverage, actual_by_slot)
        all_results.append({
            'date': date,
            'status': status,
            'assignments': assignments,
            'analysis': analysis,
            'group_maxes': group_maxes
        })
        print(f"{date_str}: {status} - {analysis['num_shifts_used']} shift, Toplam: {analysis['total']}")
    else:
        print(f"{date_str}: {status}")





# =============================================================================
# 7. Ã–ZET TABLO
# =============================================================================

print(f"\n{'='*80}")
print("Ã–ZET TABLO")
print(f"{'='*80}")

print(f"\n{'Tarih':<12} {'Toplam':>10} {'Inhouse':>10} {'Outsource':>10} {'Out %':>10} {'Shift #':>10}")
print(f"{'-'*12} {'-'*10} {'-'*10} {'-'*10} {'-'*10} {'-'*10}")

for r in all_results:
    date_str = pd.to_datetime(r['date']).strftime('%Y-%m-%d')
    a = r['analysis']
    print(f"{date_str:<12} {a['total']:>10} {a['inhouse']:>10} {a['outsource']:>10} {a['outsource_pct']:>9.1f}% {a['num_shifts_used']:>10}")

# Ortalama
if all_results:
    avg_outsource = np.mean([r['analysis']['outsource_pct'] for r in all_results])
    avg_shifts = np.mean([r['analysis']['num_shifts_used'] for r in all_results])
    print(f"{'-'*12} {'-'*10} {'-'*10} {'-'*10} {'-'*10} {'-'*10}")
    print(f"{'ORTALAMA':<12} {'':<10} {'':<10} {'':<10} {avg_outsource:>9.1f}% {avg_shifts:>10.1f}")


# =============================================================================
# 8. GRUP MAX'LARI
# =============================================================================

print(f"\n{'='*80}")
print("GRUP BAZLI DENGELEME - MAX KÄ°ÅžÄ° SAYILARI")
print(f"{'='*80}")

print(f"\n{'Tarih':<12} {'Sabah':>10} {'GÃ¼ndÃ¼z':>10} {'Ara':>10} {'AkÅŸam':>10} {'Gece':>10}")
print(f"{'-'*12} {'-'*10} {'-'*10} {'-'*10} {'-'*10} {'-'*10}")

for r in all_results:
    date_str = pd.to_datetime(r['date']).strftime('%Y-%m-%d')
    gm = r['group_maxes']
    print(f"{date_str:<12} {gm.get('sabah', 0):>10.0f} {gm.get('gunduz', 0):>10.0f} {gm.get('ara', 0):>10.0f} {gm.get('aksam', 0):>10.0f} {gm.get('gece', 0):>10.0f}")


# =============================================================================
# 9. SHIFT DETAYLARI (Ä°LK 3 GÃœN)
# =============================================================================

print(f"\n{'='*80}")
print("SHIFT ATAMALARI DETAYI")
print(f"{'='*80}")

for r in all_results[:3]:
    date_str = pd.to_datetime(r['date']).strftime('%Y-%m-%d')
    print(f"\nðŸ“… {date_str} - {r['status']}")
    print(f"{'-'*60}")
    
    # Inhouse
    print("\nINHOUSE:")
    print(f"   {'Shift':<25} {'Saat':<15} {'KiÅŸi':>10}")
    print(f"   {'-'*25} {'-'*15} {'-'*10}")
    for shift, count in sorted(r['assignments'].items()):
        if '_inhouse' in shift.lower() and shift in shift_coverage:
            info = shift_coverage[shift]
            saat = f"{info['start']}-{info['end']}"
            print(f"   {shift:<25} {saat:<15} {count:>10}")
    
    # Outsource
    print("\nOUTSOURCE:")
    print(f"   {'Shift':<25} {'Saat':<15} {'KiÅŸi':>10}")
    print(f"   {'-'*25} {'-'*15} {'-'*10}")
    for shift, count in sorted(r['assignments'].items()):
        if '_outsource' in shift.lower() and shift in shift_coverage:
            info = shift_coverage[shift]
            saat = f"{info['start']}-{info['end']}"
            print(f"   {shift:<25} {saat:<15} {count:>10}")


# =============================================================================
# 10. KARÅžILAÅžTIRMA GRAFÄ°KLERÄ° (Ä°LK 2 GÃœN)
# =============================================================================

print(f"\n{'='*80}")
print("KARÅžILAÅžTIRMA GRAFÄ°KLERÄ°")
print(f"{'='*80}")

for r in all_results[:2]:
    compare_actual_vs_mip(
        date=r['date'],
        queue=queue,
        df_actual=df_actual,
        assignments=r['assignments'],
        shift_coverage=shift_coverage
    )

print("\nâœ“ MIP optimizasyonu tamamlandÄ±!")
